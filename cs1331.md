Davis Palmie
# CS 1331 Intro to Object Oriented Programming

## Lesson 1: Introduction to Java 

Basic elements of java programs:
- statements can be grouped together using a method
- a program must have at least one or more methods
- in order to be executable, a program must have a method called "main"
- methods are enclosed in classes
- a program must have one or more classes

Example: simple program that prints text on the terminal
```java
public class HelloWorld { 
    public static void main(String[] args) {
        System.out.println("Hello,World!");
    }
}
```

The first line of the example is called the header and has a class called HelloWorld
The next line contains a method called main
To comment a single line, use //

To save the code:
- the file name must match the class (example: class in example is HelloWorld)
- the extension must be ".java"
- the example would be saved as HelloWorld.java

Camel Casing: the practice of capitalizing the first letter of words in phrases
for readability (example: MyName)

Two commonly used translators used in coding are compilers and interpreters
Both take high level programs to low level machine code
Compilers: generally faster, only need to compile once, examples include C and C++
Interpreters: require translation each time, examples include Python and PHP

Java takes a hybrid approach to compilation / interpretation --> 
compiler generates bytecode and stores it as .class file which is interpreted
by a Java Virtual Machine

To compile a java file ⟶ in terminal type the command: javac 'filename.java'
    If there are no warnings or errors then it successfully compiled
To execute the code ⟶ in terminal type the command: java 'ClassName'
    Example: java HelloWorld

## Lesson 2: Why Object-Oriented Programming 

Identifiers ⟶ names that programmers use to label classes, methods, variables, and 
other elements

Rules for identifiers:
- they can contain letters, digits, underscores _ , and $
- a digit cannot be a starting character
- identifiers cannot be reserved words (words that already have meaning)

Java is case-sensitive, and reserved words are all lowercase
Example: public Class is ok, public class is not ok because 'class' is reserved

Variable ⟶ a place in memory that stores some value
Variables have identifiers so you can properly refer to their value and location
It is a Java convention to use camel casing for variable names with first letter lowercase
Example: myVariable

Java associates specific sets of values with a type:
Type | Size | Holds
---- | ---- | ----
byte | 8 bit size | ranges from -128 to +127
short | 16 bit size | ranges from -32768 to +32767
int | 32 bit size | ranges from -2147483648 to +2147483647
long | 64 bit size | ranges from -9E18 to +9E18
double | 64 bit size | ranges from -1.8E308 to 1.8E308
string | type for storing sequences of characters

A variable declaration statement has the format <type> <identifier>;
Example: 
```java 
int saturdayFarenheit; 
```

Java is statically typed --> you need to declare a variable before you use it

A variable assignment statement has the format <identifier> = <expression>;
Example: saturdayFarenheit = 78;
In this example 78 is known as a literal or a constant
Each literal has a default type associated with it
The type of variable must be compatible with the type of value being assigned

To compile and run FarenheitToCelsius program:
- ensure you are in the right directory
- javac FarenheitToCelsius.java
- confirm that you have a source file and class file with command ls
- java FarenheitToCelsius

The attributes of an object collectively represent its state, and the actions make 
up its behavior

If a car is an 'object', it has attributes like color, make, model and actions 
like starting the engine, braking, accelerating

You can manipulate an object by calling one or more of its methods

Each object that is created from a class has its own copy of the class's
state variables

To replace class files and update code --> have to re-compile

******************************
********** MODULE 2 **********
******************************

************************************
***** Lesson 3: Back to Basics *****
************************************

Whitespace: represents blanks, tabs, and newline characters
Helps provide separation between words and symbols
There will always be some whitespace in your code

3 types of errors a program can have:
- Compiler: typically represents syntax violations in code
- Runtime: typically represents issues when the code is executed
- Logical: typically represents semantic issues in code

It becomes important to incrementally write and test code to avoid logical errors
Recommended to test after writing each method and class

Syntax --> is the statement legal in Java?
Semantics --> what is the statement trying to achieve?
Code that is syntactically correct is not always semantically correct

More review:
Example - Dog is the class
Breed, Size, Age, Color are the states or attributes
Eat(), Sleep(), Sit(), Run() are the methods

Java has three kinds of comments: 
- Line comments --> marked by starting with // 
- Block or multi-line comments --> start with /* and end with */
- Javadoc comments --> start with /** and end with */

Javadoc comments scans source code for certain comments and generates nicely
formatted HTML files that describe your code

You can declare a variable like: final double PI = 3.14159
The reserved word final has different uses:
- it can prevent a variable from being assigned a value after initialization
- now the variable is not a variable identifier, it is a constant identifier

A variable's scope represents the parts of the program that the variable's 
identifier can be used to refer to it

One method cannot see the variables that are declared in another method

Primitive types: most basic type of data built into Java
- byte
- short
- int 
- long
- float
- double
- char
- boolean
The first four are integer based, the next two are real number values (floating
point values), char --> individual characters, boolean --> true and false (logic
based values)

The greater the storage used by a integer type or floating point type, the wider
the range that can be stored
You might use one type instead of another to save memory

The int type is the default type for an integer literal
The double type is the default type for a floating point number
You can overwrite the type as follows:
- long reallyBigNum = 99999999999; --> this will error because long != int
- long reallyBigNum = 99999999999L; --> the L makes it long = long
- long reallyBigNum = 99999999999l; --> also works, uppercase is recommended
F or f can be used to overwrite a double to a float
- float fraction1 = 0.1331F --> fixes error, uppercase is preferred
D or d can be used to overwrite a numeric type to a double

The char type represents individual characters
The term set is preferred to range for characters

ASCII --> contains uppercase and lowercase letters, digits 0-9, punctuation 
marks, space characters, and some other special characters

Java char type uses unicode (superset of ASCII)

To make a char, just enclose in ''
Example: char highestGrade = 'A';
Example: char space = ' ';
Do not use a double quote "" for char, these are for strings only

An escape sequence consists of 2 special characters that have a special meaning
to the compiler, like \'
- the first is always a backslash which alerts the compiler that the next
character is to be treated differently
- the second is a descriptor of the character you are trying to store

Common escape sequences in Java:
- \t --> new tab
- \n --> new line
- \r --> carriage return
- \\ --> backslash
- \" --> double quote
- \' --> single quote

The boolean type can be true or false
This is useful for representing things that have 2 distinct states

Expression: combination of operators, operands, or method calls in a single
Java statement that must evaluate to a single value

Operator and symbol:
- addition --> + 
- subtraction --> -
- multiplication --> *
- division --> /
- remainer (or modulus) --> % (example: 3 % 2.5 --> 0.5)
With negative numbers, the remainder is always the sign of the first operand
Example: -22 % 3 --> -1

Integer division is a bit weird in Java:
Example: 9 / 2 --> 4
Example: 9.0 / 2 --> 4.5
Example: 9.0 / 2.0 --> 4.5
Or you can append letters as mentioned above
Example: 9D / 2 = 4.5
Example: 9 / 2D = 4.5

You can use the + to concatenate string literals
Example: "13" + "31" --> "1331"

Java follows the same left to right order of operations as in algebra
You can force higher precedence using parenthesis

An expression with operands of the same type will have a result of that type
Example: 1331.0 / 4.0 = 332.75
Example: 1331 / 4 = 332

Promotion: Java automatically promotes the whole expression to the same type
if one operand is a long, float, or double

Mixed type expression table:
- string + int: "13" + 31 --> "1331"
- string + char: "1331" + '1' --> "13311"
- double + string: 13.3 + "1" --> "13.31"
- boolean + string: false + "" --> "false"
- string + boolean: "" + true --> "true"
- int + string: 1331 + "" --> "1331"
- string + char: "" + 'A' --> "A"

Two other kinds of type conversion: Assignment Conversion and Casting
Assignment conversion --> automatic, occurs during variable assignment
Example: int average = 4; double gpa = average --> works fine
Example: double average = 4.0; int gpa = average; --> possible loss of precision error

Legality of possible assignment conversion is based on whether the range of numbers
of the variable's type can fit the range of numbers of the value's type
Helpful rules:
- byte fits in short
- char, short, byte fit in int
- char, short, byte, int fit in long
- char, short, byte, int, long fit in float
- char, short, byte, int, long, float fit in double

Casting is an explicit form of type conversion
Example: (double)5 / 9 --> tells Java to treat 5 as double, and
9 is promoted to its double value automatically
Example: double average = 4.0; int gpa = average; --> possible loss of precision error
Example: double average = 4.0; int gpa = (int)average; --> works fine
Casting applies to more than just numeric types

**********************************************
***** Lesson 4: Using Predefined Classes *****
**********************************************

Classes are types that can have values that are more than just a single data element
Still follows convention <type> <identifier>; example --> String major;

Object variables are officially called reference variables
Java objects are stored in the heap space

Instantiation: process of creating an object

Use the new operator to create a new instance of a class
Calls a special method of the class called a constructor
Example: new ClassName (parameters)

Example: last three lines are interchangeable
String major;
- major = new String("Computer Science"); 
- String major = new String("Computer Science");
- String major = "Computer Science";

Four major parts of Java: Syntax, Compiler, JVM, API (Standard Library)
API stands for application programming interface

println() --> prints to terminal, automatically adds newline character
print() --> prints to terminal, does not add newline character

Invoking methods template: 
identifier.methodName(parameters)
Example:
String major;
major = new String("Computer Science");
major.length(); --> returns 16

Saying a method has returned means that it finished executing without error
No object owns a method of its class

When two variables point to the same object, they are called aliases

A method's signature consists of the method's name and a representation of 
the type and position of each parameter (shown below with String methods)

String methods:
- concat(String)
- replace(char, char)
- substring(int, int)
- toLowerCase()

Example:
String interest = "Long Walks On The Beach";
String interestLower = interest.toLowerCase --> "long walks on the beach"

IMPORTANT
Strings are immutable --> when it is created it will always stay the same
This has a lot of security and performance benefits
Remember this for any trick questions

For complete information --> Java API documentation from Oracle

Calling object: object to the left of the dot operator

Formal parameter: a variable that is listed in a method header and will
be assigned a value before the method's statements are executed
Example: public String concat(String str) --> str is a formal parameter

Actual parameter: represents the value that is actually assigned to a
method's formal parameter --> also called arguments

Java is pass by value, not pass by reference

Replace method: String replace(char oldChar, char newChar);

Index: an integer that represents the position of a character in a string
Java begins indexing at 0
Indexing out of range will yield an error

Substring Method: copies part of string with start index and end index 
(ends just before the ending index)
Example: 
String major = "computer science";
major.substring(3,6); --> "put"

Some other core string methods: indexOf(), lastIndexOf(), charAt()

******************************
********** MODULE 3 **********
******************************

**************************************
***** Lesson 5: Input and Output ***** 
**************************************

To read terminal input --> use class in API called "scanner"

Example: syntax to create scanner object
public class FarenheitToCelsius {
	public static void main(String[] args) {
	    Scanner input = new Scanner(System.in); // reads keyboard input
	}
} 

A scanner object like the one above will handle all inputs for programs
Boundaries between tokens are defined by a particular sequence of characters
called a delimiter --> default is whitespace but that can change

Methods that return tokens as numeric or string values:
- nextInt
- nextDouble
- next
- nextLine

nextInt and nextDouble read individual tokens and return them as ints and
doubles, respectively
next() reads a token and returns it as a string value
nextLine() also returns a string but keeps pulling characters from the stream
until it reaches a newline character

To use scanner you need an import line at the top of your code for the compiler
Syntax: import java.util.Scanner;

The values entered must match the next method you have supplied - otherwise 
there will be an error - this can be accounted for with conditional statements

Example: multiple inputs -->

import java.util.Scanner;
public class FarenheitToCelsius {
	public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("Enter a Farenheit value: ");
        int farenheit = input.nextInt();
        System.out.print("Enter a day of the week: ");
        String day = input.next();
        double celsius = (5.0/9) * (farenheit - 32);
        System.out.println(day + " Farenheit: " + farenheit);
        System.out.println(day + " Celsius: " + celsius);
	}
}

Instead of a single token response for a prompt, it is possible for the user's 
input to be broken into multiple tokens

Example: multiple tokens on one input line --> 

import java.util.Scanner;
public class FahrenheitToCelsius {
   public static void main(String[] args) {
      Scanner input = new Scanner(System.in);
      System.out.print("Enter a Fahrenheit value and the day of the week: ");
      int fahrenheit = input.nextInt(); 
      String day = input.next(); 
      double celsius = (5.0/9) * (fahrenheit - 32); 
      System.out.println(day + " Fahrenheit: " + fahrenheit);
      System.out.println(day + " Celsius: " + celsius);
   }
}

Leading or trailing spaces can be removed by calling the String method trim
like String day = input.nextLine().trim();

Packages --> classes grouped together based on the functions they provide
The java.lang package does not require an import, but other classes like
java.util package must be imported

Syntax: import packageName.memberName;
Example: import java.util.Scanner;

Packages have multiple dot separations because each term represents a level
in a package hierarchy like "java", "util", "Scanner"
The package and member name (like java.util.Scanner) represent what is called
a fully qualified name of a package member

Using java.util.*; will import all members of the java.util package since
* is a wildcard character --> be careful because different packages can have
classes with the same name; this may also cause more overhead during compile
time but nothing for run time

To perform formatting on terminal output there are a few options:
- printf is one method --> stands for print formatted
- syntax: System.out.printf(formatString, value(s));

Example: moving from println to printf
Println: System.out.println(day + " Celsius: " + celsius);
Printf: System.out.printf("%s Celsius: %f\n", day, celsius);
These both will print the same thing

%f and %s are examples of format specifiers
The template for using them is %[flag][width][.precision]type
Example: for one decimal place --> %.1f
Width value determines how many character positions a string value
will consume when printed (Example: %10s) --> can be used to align

Type:
- decimal (all integers) --> character: d
- floating point (float, double) --> character: f
- string --> character: s

Just like print, printf does not insert a newline character --> you have
to add the \n yourself

For printf, the type order of the parameters must be compatible with the type
order of the format specifiers otherwise it will not work

The String class's format method works exactly like printf, except it will
not print the formatted string on the terminal
Example: String celsiusOutput = String.format("%s %-11s %,.1f \n", day, cText, celsius);

NumberFormat is quite special because it supports internationalization -->
meaning its objects's behaviors can change depending on the geographic location
of the computer

Example: Internationalization

import java.util.Scanner;
import java.util.Locale;
import java.text.NumberFormat;


public class CurrencyDemo {
    public static void main(String[] args) {
        int items;
        double itemCost, total;
        Scanner input = new Scanner(System.in);
        System.out.print("Enter the number of items: ");
        items = input.nextInt();
        System.out.print ("Enter the cost per item: ");
        itemCost = input.nextDouble();
        total = items * itemCost;
        System.out.println();
        System.out.println ("Unformatted Total: " + total);
        NumberFormat currencyFmt = NumberFormat.getCurrencyInstance(Locale.FRANCE);
        System.out.println ("Formatted Total: " + currencyFmt.format(total));
    }
}

DecimalFormat is also useful because you can specify your own patterns or templates
for how formatted numbers should look

Example: DecimalFormat formatter = new DecimalFormat("0.0");

How to interpret patterns with only zeros and a decimal point:
- a digit 0 in some pattern's position guarantees there will be a digit in that
position for any formatted result
- if the number being formatted has an actual digit in the same position of some 0
in that pattern, that number's digit will be shown in that position in the formatted
result
- if the number being formatted does not have a digit in the same position of some 0 
in that pattern, the formatted result will fill that position with an actual 0 digit
- if there are more decimal places in the number to be formatted than found in the 
pattern, the formatted result will round the number to a value with the same number
of decimal places as specified in the pattern
- if a % is found at the end of a pattern, the format method will return a percentage
value that represents the input
- the number of zeros to the left of the decimal do not constrain the number of digits
that the format method will use from its input value 

You can use other pattern symbols other than 0 and % --> look into documentation
# will allow you to write patterns with optional digits

Example: #.00 makes the whole number digit optional 

Example: 
DecimalFormat formatter = new DecimalFormat("0.0");
String formattedNum = formatter.format(0.8675309);

Look at lecture code folder for a more in-depth example

************************************************
***** Lesson 6: Decision Making Statements *****
************************************************

The three decision making statements we will be looking at are the if, 
if-else, and switch statements --> they work by tying the execution of blocks
of code to evaluation of one or more specified conditions

These decision making statements are also commonly called conditionals

Syntax: Single statement

if (booleanExpression)
    statement;

Syntax: Multiple statements

if (booleanExpression) {
	statement1;
	statement2;
	statement3;
}

Relational operators include <, >, <=, and >=
< indicates less than
> indicates greater than
<= indicates less than or equal to
>= indicates greater than or equal to

Equality operators include == and !=
== indicates equal to
!= indicates not equal to

Recall that all characters are represented in unicode in Java
Digit characters are found before letters -->
('Z' < 'a') and ('0' < 'A') are both technically true

When applying an equality operator to reference variables, Java checks
to see if the references are aliases - if they point to the same object

To compare the contents of two strings, use the method boolean equals(Obj1 Obj2)
Method tests if the two strings contain the exact same sequence of chars
equals() compares the content while == compares the memory location

Example:
if x and y are different strings -->
(x.equals(y)) evalues to false
(!x.equals(y)) evalues to true

When creating strings, remember that String x = "park"; does not equal
String x = new String("park");

String interning --> storing only one copy of each distinct String value 
which is immutable

For strings, use the compareTo() method instead of relational operators
Syntax: int result = x.compareTo(y);
Return values:
- 0 means x and y are equal, x.equals(y) is true
- negative int value means x is less than y
- positive int value means x is greater than y

Instead of a string comparison like x > y (illegal), it would be rewritten as
x.compareTo(y) > 0

If-Else Single Statement Syntax:

if (booleanExpression)
    statement1;
else
    statement2;

If-Else Multiple Statements Syntax:

if (booleanExpression) {
	statement;
	statement;
	statement;
}
else {
	statement;
	statement;
	statement;
}

There are three logical operators in Java:
AND --> symbol is &&
OR --> symbol is ||
NOT --> symbol is !

AND and OR are binary operators while NOT is unary, meaning that it is 
applied on single operands

AND and OR operator table:
false && false --> false
false || false --> false
false && true --> false
false || true --> true
true && false --> false
true || false --> true
true && true --> true
true || true --> false

Video example had methods toLowerCase() and startsWith() which seem useful

You can extend boolean expressions with other operators as long as the final 
results are true or false values --> example is below:
if ((satFarenheit + sunFarenheit) / 2 >= MIN_TEMP) {
	System.out.println("Yay! Nice temperature.");
}

Parenthesis to group operands are not always needed but can help with readability
Order of operations: !(NOT), arithmetic, relational, equality, binary logical

Short circuit evaluation: 
-Java evaluates && expressions starting on the left side and if that operand's 
value is false, it does not need to evaluate any other terms
-Java evaluates || expressions starting on the left side and if that operand's 
value is true, it does not need to evaluate any other terms
Performance benefits tie in to short circuit evaluation because the less
complicated term should ideally be put on the left side

Nesting means putting one thing inside of another, like putting an if statement 
within another if statement

Dangling else problem --> in Java else branch is matched to its closest 
unmatched if branch

Ternary conditional operator: a one line replacement or shortcut to if-else
statements - requires 3 operands
Syntax: condition ? expression1 : expression 2
First operand is a condition which results in a boolean value --> if it is
true, then the operator returns the result of evaluating expression1, 
otherwise the operator returns the result of evaluating expression2

Example: Rewriting an if-else statement

if (rainInput.startsWith("y")) {
    raining = true;
}
else {
    raining = false;
}

can be rewritten as

raining = rainInput.startsWith("y") ? true : false;

Another example: with string concatenation

System.out.println(fahrenheit + " " + (((fahrenheit == 1) || (fahrenheit == -1) 
                                           ? "degree" 
                                           : "degrees"));

Multi-way branching --> using if, else if, else
Syntax:
if (condition1) {
	statement(s)
}
else if (condition2) {
	statement(s)
}
else {
	statement(s)
}

Another way to achieve multiway branching is the switch statement:
Switch statement syntax:
switch (expression) {
	case value1:
	    statement(s)
	    break;
	case value2:
	    statement(s)
	    break;
	default:
	    statement(s)
}

The expression for a switch statement can be a variable or something more 
complex as long as it evaluates to char, byte, short, int, String, enum, 
Character, Byte, Short, or Integer

Example: 
// some code
int selection = input.nextInt();
String menuOption;
switch (selection) {
	case 0:
	    menuOption = "Operator";
	    break;
	case 1:
	    menuOption = "Billing";
	    break;
	default:
	    menuOption = "Retry Selection";
	    break;
}

Switch statements are considered to be less safe than multiway if-else 
statements, and they can only contain a single value to match the specified
expression unlike multiway if-else statements

******************************************************
***** Lesson 7: Iteration (or Repetition) Part 1 ***** 
******************************************************

The term loop statements are generally used for the while, do-while, and 
for loops

while statement:
cycle continues until condition is false
ctrl c will stop an infinite loop

while statement for one statement syntax:

while (booleanExpression)
    bodyStatement;

while statement for multiple statements syntax:

while (booleanExpression) {
    bodyStatement1;
    bodyStatement2;
}

Example: While Loop

public class HelloWorldLoop {
    public static void main(String[] args) {
    int lineNum = 1;
    while (lineNum <= 10) {
        System.out.println("Hello, World! " + lineNum);
        lineNum++
        }
    }
}

Note that ++ will increase by 1 every loop and -- will decrease by 1 every loop
These are called the increment and decrement, respectively

While loops need an initialization of the counter variable, a comparison,
and an update to the counter variable in the body of the loop

The do-while statement is like an upside down while statement --> it is
useful when you know you will need to execute at least 1 iteration of code
and maybe more iterations after

Do-while statement --> always executes once, then executes if the condition is 
true, and stops once the condition is false

Syntax for do-while statement:

do {
    bodyStatement1;
    bodyStatement2;
} while (booleanExpression);

For statements are great when we know how many iterations to perform

Syntax for a for loop:

for (initStatement; condition; updateStatement) {
    bodyStatement1;
    bodyStatement2:
}

Example: For loop

public class HelloWorldLoop {
    public static void main(String[] args) {
        for (int lineNum = 1; lineNum <= 10; lineNum++) {
            System.out.println("Hello, World!");
        }
    }
}

It matters if you declare your for loop variable in the loop header or
before the for loop --> if you declare it in the loop header you will
not be able to access it after the loop

Example: For loop with power multiplication 

public class PowersOfTwo {
    public static void main(String[] args) {
        for (int pow = 1; pow <= 40; pow*=2) {
            System.out.println(pow);
        }
    }
}

You can nest loops inside of each other to get multiple levels of repetition

Example: Nested while loop (performs 50 iterations)

public class HelloWorldLoop {
    public static void main(String[] args) {
        int outerCounter = 1;
        while (outerCounter <= 5) {
            int innerCounter = 1;
            while (innerCounter <= 10) {
                System.out.println("Hello, World!");
                innerCounter++;
            }
            outerCounter++;
        }
    }
}

Example: Nested for loop

public class Powers {
    public static void main(String[] args) {
        final int LIMIT = 40;
        for (int base = 2; base <= 5; base++) {
            System.out.println("Powers of " + base + " under " + LIMIT);
            for (int pow = 1; pow <= 40; pow *= base) {
                System.out.println(pow);
            }
            System.out.println();
        }
    }
}

Reaching a break statement can exit a while, do-while, or for statement
just like using a break statement within a switch statement

Using the break statement will jump execution to the code after the 
statement containing break

The continue statement, however, will jump out of a loop iteration to the 
next cycle, but it will not terminate the loop like a break statement
L7 continue statement video has a good long example 

Exam 1 will cover L1 - L7
End of material for first exam is above

******************************
********** MODULE 4 **********
******************************

****************************
***** Lesson 8: Arrays *****
****************************

Arrays allow for storage of values together under a single name
Java arrays allow for theoretical storage of billions of values that are accessible with one variable


Array --> ordered sequence of values in which each element is of the same type
The elements are the values that make up an array
The places of each element in the array are called the indices (singular - index)

Declaring an array: 
Syntax --> elementType[] identifier; (this is preferable)
Syntax --> elementType identifier[];

Creating an array:
Syntax --> new elementType[Length];

Example:
double[] weekHighs = new double[7];

The type of the created array must match the type used in the declaration
Once an array is created, their length is fixed --> cannot be lengthened or shortened

Example:
String[] month = new String[12];

Default values:
numeric array --> default value is 0
boolean array --> default value is false
object array (like Strings) --> default value is null

null is a Java keyword that means the reference variable has no address
represented graphically by a line with a flat head

Example: specifying array values
double[] weekHighs = {80, 75, 70, 69, 72, 74, 90};
must have declaration and initialization in the same line

Example: alternative way to fill by indexing
double[] weekHighs = new double[7];
weekHighs[0] = 80;
weekHighs[1] = 70;
weekHighs[2] = 75;
weekHighs[3] = 69;
weekHighs[4] = 72;
weekHighs[5] = 74;
weekHighs[6] = 90;

Example: using scanner
Scanner input = new Scanner(System.in);
double[] weekHighs = new double[7];
weekHighs[0] = input.nextDouble();

Example: array loop averager

public class Avenger {
    public static void main(String[] args) {
        double[] weekHighs = {80, 70, 75, 69, 72, 74, 90};
        double highsSum = 0;
        for (int index = 0; index < weekHighs.length; index++) {
            highsSum = highsSum + weekHighs[index];
        }
        double averageHighs = highsSum / weekHighs.length;
        System.out.println("Average is: " + averageHighs);
    }
}

Indexing out of bounds will result in an error when the program runs
The for-each statement can traverse arrays without having to index

For-each syntax:

for (arrayType element : array) {
    bodyStatement1;
    bodyStatement2;
}

Example: averager using for-each

public class Averager {
    public static void main(String[] args) {
        double[] weekHighs = {80, 70, 75, 69, 72, 74, 90}; //initialization
        double highsSum = 0;
        for (double dayHigh : weekHighs) {
            highsSum = highsSum + dayHigh;
        }
        double averageHighs = highsSum / weekHighs.length;
        System.out.println(averageHighs);
    }
}

Example: searching arrays

public class ArraySearch {
    public static void main(String args[]) {
        String[] concepts = {"abstraction", "polymorphism", "inheritance", "encapsulation"};
        String result = "not found";
        for (String concept : concepts ) {
            if (concept.equals("polymorphism") ) {
                result = "found";
                break;
            }
        }
        System.out.println(result);
    }
}

The for statement traverses the array with the assumption that it is non-sparse
Non-spare means that none of the elements are assigned a value of null
If the equals method is called on a null element --> error

Example: addressing null error

public class SparseArraySearch {
    public static void main(String args[]) {

        String[] concepts = new String[5];
        concepts[0] = "abstraction";
        concepts[2] = "polymorphism";
        concepts[3] = "inheritance";
        concepts[4] = "encapsulation";

        String result = "not found";

        for (String concept : concepts ) {
            if ((concept != null) && (concept.equals("polymorphism"))) {
                result = "found";
                break;
            }
        }
        System.out.println(result);
    }
}

args is a reference to a string array
You can provide command-line arguments for args

Example: command line arguments

if I type java Averager 5 2 5 in the terminal, args will be a string array of 5 2 and 5

Double is a utility class that offers commonly used methods for double operations
For converting from a string, Double.parseDouble(stringArray);
There is a wrapper class for each primitive type

Arrays of arrays are known as 2D arrays
Syntax for creating 2D arrays:

elementType[][] identifier;
elementType identifier[][];
either one works

The template for accessing elements in a 2D arrays is identifier[row][col]

Example: different ways to create 2D arrays

double[][] array2d = {{80, 70, 75}, {69, 72, 74}};

double[][] array2d = {{80, 70, 75}, 
                      {69, 72, 74}};

You can also use the new operator to create 2D arrays
Example: double[][] array2d = new double[2][3];
This means that the array2d will have 2 rows and 3 columns of 0.0s (default double value)

Example: manually assigning 2D array values

array2d[0][0] = 80;
array2d[0][1] = 70;
array2d[0][2] = 75;
array2d[1][0] = 69;
array2d[1][1] = 72;
array2d[1][2] = 74;

For 2D array processing, you can either take a row major approach or column major approach
Row major --> moves row by row
Column major --> moves column by column

For row major 2D array traversal:

for (int row = 0; row < array2d.length; row++) {
    for (int col = 0; col < array2d[row].length; col++) {
    }
}

Example: column major 2D array traversal

for (int col = 0; col < array2d[0].length; col++) {
            for (int row = 0; row < array2d.length; row++) {
                if ((array2d[row][col] >= MIN_TEMP) && (array2d[row][col] <= MAX_TEMP)) {
                    System.out.println("Go to the park.");
                }
            }
        }

Study --> will need to do a traversal on a test

Java allows ragged arrays, which have rows of varying length
This makes it very important to use the array length constant and not a literal when traversing

Example: creating ragged arrays

double[][] array2d = {{80, 70, 75}, 
                      {69, 72, 74, 90}};

double[][] array2d = new double[2][];
// Fill first row with new 3-element array.
array2d[0] = new double[3];
array2d[0][0] = 80;
array2d[0][1] = 70;
array2d[0][2] = 75;
// Fill second row with a new 4-element array.
array2d[1] = new double[4];
array2d[1][0] = 69;
array2d[1][1] = 72;
array2d[1][2] = 74;
array2d[1][3] = 90;

Java allows for multi-dimensional arrays of over two dimensions
You can create an array of arrays of arrays --> 3D array
This course will focus on 2D arrays

*****************************
***** Lesson 9: Methods *****
*****************************

Methods are the core building blocks of classes and objects
A method allows a programmer to group related statements together and give them a name
This allows to modularize program - meaning break them into small and manageable pieces

Another benefit of methods is reusability

The least amount of information you need for a method header is a return type which represents the type of data the method will return it its caller, the method name, and the list of any formal parameter declarations within parentheses. Remember that any formal parameters represent input that you can use within the method definition

In summary: return type, method name, format parameters - in that order

Example: making a method (declare outside of main)

public static String searchStringArray(String target, String[] array) {
    for (String element: array) {
        if (element.equals(target)) {
            result = "found";
            break;
        }
    }
    return result;
}

Remember that what you return must match the type you specify in the method header
When Java reaches a return statement it ends the execution of the method that contains the return statement
Any statements after a return statement are unreachable and will cause an error

Example: making a boolean method (declare outside of main)

public static boolean searchStringArray(String target, String[] array) {
    boolean result = false;
    for (String element: array) {
        if (element.equals(target)) {
            result = true;
            break;
        }
    }
    return result;
}

Since you cannot import the custom methods that you create, if you want to call a method you have created the two files must be in the same folder

External method calls --> access it using YourClassName.customMethod

Example: search method for int arrays

public static boolean searchIntArray(int target,
                                     int[] array) {
   boolean result = false;
   for (int element : array) {
       if (element == target)) {
           result = true;
           break;
       }
   }
   return result;
}

In Java to overload a method you need two or more versions with the same name but different types, order, and/or number of formal parameter

Example: overloaded method

public class ArraySearch2 {
    public static boolean searchArray(String target,
                                      String[] array) {
        boolean result = false;
        for (String element : array) {
            if ((element != null) && (element.equals(target))) {
                result = true;
                break;
            }
        }
        return result;
    }


    public static boolean searchArray(int target,
                                      int[] array) {
        boolean result = false;
        for (int element : array) {
            if (element == target) {
                result = true;
                break;
            }
        }
        return result;
    }
}

At compile time: when Java sees a call to an overloaded method --> examines actual parameter list and searches for method with matching signature
At run time: JVM already knows which version of method to execute

Overloading is not new --> already used for println()
Changing return types or modifiers does not achieve overloading

******************************
********** MODULE 5 **********
******************************

*************************************************************
***** Lesson 10: Introduction to Writing Classes Part 1 *****
*************************************************************

Classes (like methods) offer the benefit of modularity and reusability with more scale
Prior classes that we have worked with are called client classes --> we did not write
Now we will make classes that are instantiable 

Starting point for blueprint classes --> identifying behavior and properties

Instance variables are not local to a specific method or block statement
These are declared at the class level, outside of any method

Example: instance variable syntax
public class Insect {
    private double weight;
    private int x;
    private int y;
}

Any variable or method that is declared in this scope is called a class member
Instance variables are class members and not local variables
The convention is to declare instance variables right below the class header

Java has visibility modifiers --> private and public (two more talked about later)
The keyword private controls which classes can access and manipulate the variables

"Private" enforces encapsulation by giving access to an instance variable only to the methods within its class
Instance variables should not be public due to encapsulation

Example: one way to test objects
Inside the insect class code and after the instance variables -->
//test method
public static void main(String[] args) {
    Insect buzz1 = new Insect();
    Insect buzz2 = new Insect();
}

Any class we write is given a default constructor which initializes each instance variable with default values
For instance variable types:
* numeric primitive types --> default type 0
* boolean --> default type false
* class (object type) --> default type null

We can write our own constructors to override the default values:
Constructors are the only kind of methods that can be declared with no return values
The name of a constructor must be the same as the name of the class

Example: constructor syntax
public Insect(double initWeight, int initX, int initY) {
    weight = initWeight;
    X = initX;
    Y = initY;
}

Example: putting it all together with Insect class
public class Insect {

    // instance variables
    private double weight;
    private int x;
    private int y;

    // constructor
    public Insect(double initWeight, int initX, int initY) {
        weight = initWeight;
        X = initX;
        Y = initY;
    }

    //test method
    public static void main(String[] args) {
        Insect buzz1 = new Insect(10, 100, 90);
        Insect buzz2 = new Insect(4, -300, 400);
    }

}

Instance methods --> methods that represent behaviors or actions that we can invoke on a specific object
Instance methods do not have a static modifier in their headers because they are not static

The public methods of a class are collectively called the interface

A helper method is one that is private and used internally by one or more other methods

Example: public method and helper method 

public void move(int newX, int newY) {
    double distance = calculateDistance(x, y, newX, newY);
    if (distance > 0) {
        x = newX;
        y = newY;
        weight = weight * DIST_WEIGHT_LOSS_FACTOR * distance;
        System.out.printf("Moved %.2f units\n", distance);
    } else {
        System.out.println("Staying put.");
    }
}

private static double calculateDistance(double x1, double y1, double x2, double y2) {
    return Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
}

Having the calcualteDistance helper method separate is beneficial because of modularity
Also, static methods belong to a class, and are not something you would invoke on specific instances of that class
Methods that do not represent actions that would be performed on a specific object should be static
Helper methods are typically static

The static modifier forces turns a member into a shared entity across all objects of a class
Recall: final means that the variable will not change value

Public constants do not violate encapsulation since other classes cannot change them

Example: 
Inside the insect class --> public static constant of the form:
public static final double DIST_WEIGHT_LOSS_FACTOR = 0.0001;
Outside of Insect.java, we would access this using the dot operator --> Insect.DIST_WEIGHT_LOSS_FACTOR

The class name and dot operator are only required for external classes

A static method cannot directly access a non-static member like an instance variable

Generating random values:
Math.random() returns a random double value greater than or equal to 0 and less than 1
This expression produces a random int in the range [0, max - min]: (int)(Math.random() * ((max - min) + 1));
Note --> this is not truly random but rather pseudorandom

Example: producing a random int to index a string array
int index = (int)(Math.random() * ((FACTS.length - 1) + 1));

*************************************************************
***** Lesson 11: Introduction to Writing Classes Part 2 *****
*************************************************************

Trying to access one class's private static constants or variables will throw an error

Accessors (or getters) allow a client to access a variable's value
They are still good with encapsulation since they do not change anything

Getter header template: public varType getVarName()
Getter methods do not have any parameters
Their return type is always the type of the variable they are associated with

Not every instance variable needs a getter method --> only provide for ones you think a client may need to read

Example: Insect class accessors
public double getWeight() {
    return weight;
}
public int getX() {
    return X;
}
public static int getPopulation() {
    return population;
}

Note that getter methods for static variables must also be static

Example: mutator or setter methods
public void setX(int newX) {
    if (isLegalX(newX)) {
        x = newX;
    }
}
public void setY(int newY) {
    if (isLegalY(newY)) {
        y = newY;
    }
}
public static boolean isLegalX(int newX) {
    return (newX >= 0 ? true : false);
}
public static boolean isLegalY(int newY) {
    return (newY >= 0 ? true : false);
}

Setter header template: public void setVarName(varType varName)
A setter is intended to change a variable, not return its value like a getter
Type must be the same as the type of the variable being changed

When writing a setter for an instance variable --> think of all the values and ways that an input could break the intended state of an object and write conditions in the method to prevent that (like in the above example)

It is possible to overload constructors just like methods
For example, scanner can be used like Scanner(InputStream source) or Scanner(File source)

Example: overloaded constructors
public Insect(double initWeight) {
    weight = initWeight;
    x = DEFAULT_X;
    y = DEFAULT_Y;
    population++;
}
public Insect(double initWeight, int initX, int initY) {
    weight = initWeight;
    x = initX;
    y = initY;
    population++;
}

In software engineering, the DRY principle stands for Don't Repeat Yourself

With constructor chaining --> a more specific constructor is always called by a less specific one
A less specific constructor could have less input parameters, for example
Cannot use the new operator for chaining as this operator creates a whole new object

We use the keyword this() to chain constructors
When you use this() in a constructor, it must be the first statement

Example: constructor chaining
public Insect(double initWeight) {
    this(initWeight, DEFAULT_X, DEFAULT_Y);
}
public Insect(double initWeight, int initX, int initY) {
    weight = initWeight;
    x = initX;
    y = initY;
    population++;
}

The keyword this() can also be used as a reference within a constructor or non-static method
In the example, this.varName distinguishes the instance variables from the formal parameters
Example:
public class Insect {
    //instance variables
    private double weight;
    private int x;
    private int y;

    //constructor
    public Insect(double weight, int x, int y) {
    this.weight = weight;
    this.x = x;
    this.y = y;
    population++;
    }
}

The method toString() returns a string representation of a Java object
toString() is inherent to every object
We can also write our own version of toString() if it is not being user-friendly

Example: rewriting toString()
public String toString() {
    return "weight: " + weight + ", x: " + x + ", y: " + y;
}

If a non-string object is passed as input to print or println, Java will automatically call the object's toString method and use that returned String as the actual parameter for that print call

Example: putting it all together
Sometimes a trick is nouns become classes and verbs become methods
This example can be found in die.java and craps.java in the example folder

**********************************
***** Lesson 12: Inheritance *****
**********************************

Inheritance means the transfer of attributes and behaviors from one class to another

A class through which another class is derived is called a parent class or a superclass
A derived class is called a subclass or child class

Example: If Insect is the parent class, YellowJacket is the child class

Unified modelling language (UML) is widely used to model software
In UML, a hierarchy would have arrows from the child class back to the parent class

Java does not have multiple inheritance, meaning:
A parent class can theoretically have infinite child classes
A child class, however, can only have one parent class

At the top of every inheritance hierarchy is a class in the Java standard library called Object
Object contains methods which are automatically inherited by every class

Private members are not inherited
Protected methods can only be accessed by subclasses or any other class in the same package

Modifier public can be accessed by class, package, subclass, and world
Modifier protected can be accessed by class, package, and subclass
Modifier none/default can be accessed by class and package
Modifier private can be accessed by class only

To declare a subclass, you use the keyword extends

Example: subclass syntax
public class Dog extends Canine {
    // some code here
}

The keyword super in the form of a method calls the superclass's constructor
When you call in a child class it must be the first line of the constructor

If you don't explicity invoke a parent class's constructor with a super call in a child class's constructor, Java automatically calls the parameterless super constructor at the very start of the child's constructor

The class of the object being referenced determines the method called

In method overriding --> signatures of the parent and child versions must be the same

The modifier final turns a variable into a constant
You can also use final with methods and classes
A final class is one that cannot be subclassed anymore
A method with final in the header cannot be overridden

Syntax: using final with a class
public final class MiniaturePoodle

An abstract class is a class that has at least one abstract method
An abstract method is a method that has a declaration but not a definition
If a class has an abstract method it must be declared abstract

Example: abstract class
public abstract class Canine {
    protected double size;
    public Canine(double size) {
        this.size = size;
    }
    public void bark() {
        System.out.println("Woof Woof");
    }
    public abstract void groom();
}

You cannot instantiate an abstract class
Abstract classes can contain non-abstract methods

If I have an abstract method groom() in Canine --> all subclasses must have some groom() method to override that or there will be a compiler error

Abstract classes should represent generic concepts or things (like a canine)

An overridden equals method must have the following header:
public boolean equals(Object o) --> can change the identifier o to whatever

Regardless of what o is pointing to, since its type is Object it can only invoke the Object inherited methods of: 
public boolean equals(Object obj)
public String toString()
public final Class getClass()
public int hashCode()
protected Object clone() throws CloneNotSupportedException
public final void notify()
public final void notifyAll()
public final void wait(long timeout) throws InterruptedException
public final void wait(long timeout, int nanoseconds) throws InterruptedException
public final void wait() throws InterruptedException
protected void finalize() throws Throwable

Example: writing equals() method for Dog class
public boolean equals(Object o) {
    if (!(o instanceof Dog)) {
       return false;
    }
    Dog doggy = (Dog) o;
    return ((doggy.size == size) && (doggy.name.equals(name)));
}

Exam 2 will cover through this point

******************************
********** MODULE 6 **********
******************************

************************************************
***** Lesson 13: Interfaces and Algorithms *****
************************************************

You can put a collection of objects of different types in a data structure and perform the same actions on them

Example: 
public class GroomEverything {
    public static void main(String[] args) {
        Canine[] groomer = {
            new Wolf(17.5, 3),
            new Poodle("richie", 9, "lux brand", "rich brand"),
            new Wolf(16, 5),
            new Poodle("pixy", 4, "top shelf", "only the best"),
        };

        for (Canine c: groomer) {
            // groom everything
            c.groom();
        }
    }
}

Interfaces allow us to formalize groups of 2+ classes that share behaviors but no inheritance relationships

In an interface we declare a set of abstract methods that we expect a group of classes to define in their own way
Upon compiling the interface --> get a class file that represents a new type

Any concrete or abstract class can declare itself as an implementor of the interface
Concrete class --> must define all the interface's methods or it will not compile
Abstract class --> does not have to define all the interface's methods since it can delegate that to a concrete subclass

An interface is a type
An object of the class that implements the interface is an instance of that class and its superclasses as well as the interface
No restrictions on hwo many interfaces a class implements

Abstract methods in an interface do not need the abstract modifier, it is implied
They are also automatically public

Example: creating an interface

public interface Groomable {
    public void groom();
}

To bind the interface to a class: need the implements clause and to define the interface's methods
Implements clause syntax --> public class ClassName implements InterfaceName {}

Example: binding interface to class

public class Car implements Groomable {
    // lot of code
    public void groom() {
        if (speed == 0) {
            System.out.println("vroom vroom");
        }
    }
}

Example: using the interface

public class GroomEverything {
    public static void main(String[] args) {
        Groomable[] groomer = {
            new Wolf(17.5, 3),
            new Poodle("richie", 9, "lux brand", "rich brand"),
            new Wolf(16, 5),
            new Poodle("pixy", 4, "top shelf", "only the best"),
            new Car("yuniha", "spark", 2030)
        };

        for (Groomable g : groomer) {
            // groom everything
            g.groom();
        }
    }
}

Note that Java also passes down the implements clause to subclasses via inheritance

Sorting arrays of objects --> use tried and true methods:
Merge Sort
Insertion Sort
Bubble Sort
Quicksort
Selection Sort

Sort method header that can take in any type --> public void sortName(Object[] arr) {}

Comparison logic: ((someType)arr[someIndex]).compareTo(arr[anotherIndex])

compareTo() rules:
if calling object is less than the input object - return negative int
if calling object is greater than the input object - return positive int
if calling object and input object are equal - return zero

An interface provides a way of enforcing that a class declares and/or defines one or more methods

Java has a built in interface with a compareTo method --> java.lang.Comparable
Java has a built in Arrays.sort() method to sort arrays of Objects

Example: using implements with multiple interfaces
public class Wolf extends Canine implements Groomable, Comparable {}

Example: writing a compareTo() method

public int compareTo(Object anotherWolf) {
    return -(rank - ((Wolf)anotherWolf).rank)
}

A generic type is an interface or class that is capable of accepting input that identifies the kinds of data (i.e. types) it can work with

Example: improving compareTo() method

public int compareTo(Wolf anotherWolf) {
    return -(rank - (anotherWolf).rank)
}

Example: using sort

import java.util.Arrays

// bunch of other code

public static void main(String[] args) {
    Wolf[] pack = {
        new Wolf(17, 2),
        new Wolf(3, 4),
        new Wolf(7, 9),
        new Wolf(2, 6),
        new Wolf(1, 8),
        new Wolf(19, 1),
        new Wolf(12, 2),
    };

    Arrays.sort(pack);
    System.out.println("Sorted Pack: " + Arrays.toString(pack));
}

Now we are going to look at the selection, merge, and insertion sort algorithms
Arrays.sort() uses an algorithm called Timsort which is a hybrid of insertion and merge

Selection sort: scans a list for smallest item, places item in order, scans remaining unsorted items for next smallest, places that item in order, repeats such passes until the list is sorted

Selection sort makes (n-1) passes where n is the number of items in the list

Example: selection sort for ints

public static void SelectionSort(int[] list) {
    int minIndex;
    int nextSmallest;

    for (int unSortedStart = 0; unSortedStart < list.length-1; unSortedStart++) {
        minIndex = unSortedStart;
        for (int currentIndex = unSortedStart + 1; currentIndex < list.length; currentIndex++) {
            if (list[currentIndex] < list[minIndex]) {
                minIndex = currentIndex;
            }
        }
        nextSmallest = list[minIndex];
        list[minIndex] = list[unSortedStart];
        list[unSortedStart] = nextSmallest;
    }
}

The selection sort can be adapted for many types

Example: selection sort for objects

public static void SelectionSort(Comparable[] list) {
    int minIndex;
    Comparable nextSmallest;

    for (int unSortedStart = 0; unSortedStart < list.length-1; unSortedStart++) {
        minIndex = unSortedStart;
        for (int currentIndex = unSortedStart + 1; currentIndex < list.length; currentIndex++) {
            if (list[currentIndex].compareTo(list[minIndex]) < 0) {
                minIndex = currentIndex;
            }
        }
        nextSmallest = list[minIndex];
        list[minIndex] = list[unSortedStart];
        list[unSortedStart] = nextSmallest;
    }
}

Merge sort: repetitively breaks list into halves, repetitively merges halves into sorted order

Example: merge sort for ints in ascending order (note that there are two methods)

public static void mergeSort(int[] list, int start, int end) {
    if (start == end) {
        return;
    } else if (start == end-1) {
        if (list[start] <= list[end]) {
            return;
        } else { // swap
            int temp = list[start];
            list[start] = list[end];
            list[end] = temp;
        }
    }

    int mid = (end-start)/2;
    mergeSort(list, start, start + mid);
    mergeSort(list, start + mid + 1, end);
    merge(list, start, start + mid, end);

}

private static void merge(int[] list, int leftHalfStart, int rightHalfStart, int end) {
    int leftHalfSize = rightHalfStart - leftHalfStart + 1;
    int rightHalfSize = end - rightHalfStart;

    int[] leftHalf = new int[leftHalfSize];
    int[] rightHalf = new int[rightHalfSize];

    for (int i=0; i<leftHalfSize; ++i)
        leftHalf[i] = list[leftHalfStart + i];
    for (int j=0; j<rightHalfSize; ++j)
        rightHalf[j] = list[rightHalfStart + 1+ j];

    int i = 0;
    int j = 0;

    int k = leftHalfStart;
    while (i < leftHalfSize && j < rightHalfSize) {
        if (leftHalf[i] <= rightHalf[j]) {
            list[k] = leftHalf[i];
            i++;
        } else {
            list[k] = rightHalf[j];
            j++;
        }
        k++;
    }

    while (i < leftHalfSize) {
        list[k] = leftHalf[i];
        i++;
        k++;
    }

    while (j < rightHalfSize) {
        list[k] = rightHalf[j];
        j++;
        k++;
    }
}

Note: will not have to code merge sort on an exam

A merge sort is an example of recursion - when a method calls itself

Example: Comparable-friendly merge sort for unbounded set of array types

public static void mergeSort(Comparable[] list, int start, int end) {
    if (start == end) {
        return;
    } else if (start == end-1) {
        if (list[start].compareTo(list[end]) <= 0) {

                return;
        } else { // swap
            Comparable temp = list[start];
            list[start] = list[end];
            list[end] = temp;
        }
    }

    int mid = (end-start)/2;
    mergeSort(list, start, start + mid);
    mergeSort(list, start + mid + 1, end);
    merge(list, start, start + mid, end);

}

private static void merge(Comparable[] list, int leftHalfStart, int rightHalfStart, int end) {
    int leftHalfSize = rightHalfStart - leftHalfStart + 1;
    int rightHalfSize = end - rightHalfStart;

    Comparable[] leftHalf = new Comparable[leftHalfSize];
    Comparable[] rightHalf = new Comparable[rightHalfSize];

    for (int i=0; i<leftHalfSize; ++i)
        leftHalf[i] = list[leftHalfStart + i];
    for (int j=0; j<rightHalfSize; ++j)
        rightHalf[j] = list[rightHalfStart + 1+ j];

    int i = 0;
    int j = 0;

    int k = leftHalfStart;
    while (i < leftHalfSize && j < rightHalfSize) {
        if (leftHalf[i].compareTo(rightHalf[j]) <= 0) {
            list[k] = leftHalf[i];
            i++;
        } else {
            list[k] = rightHalf[j];
            j++;
        }
        k++;
    }

    while (i < leftHalfSize) {
        list[k] = leftHalf[i];
        i++;
        k++;
    }

    while (j < rightHalfSize) {
        list[k] = rightHalf[j];
        j++;
        k++;
    }
}

You can use complexity analysis to compare sorting algorithms
Stopwatch evaluation --> which sorting algorithm minimizes runtime?

Example: stopwatch evaluation

long start = System.nanoTime();
selectionSort(input); //you can change this to any code block to collect its runtime
long end = System.nanoTime();
System.out.println("Elapsed time in ns:" + (end - start));

Good questions to ask when comparing algorithms:
Does the amount of time that an algorithm takes stay constant regardless of how big the input is?
If the amount of time grows as input size increases, is the growth directly proportional?
If things could be a lot worse, what might the rate of growth look like?

Complexity: efficiency (time or space requirements) of an algorithm in terms of input size

You can also represent an algorithm's runtime using the number of operations it takes to complete a task rather than the elapsed time

There is no constant time sorting algorithm
There can be constant time algorithms though

Example: linear search algorithm for arrays of Comparable objects

public static int linearSearch(Comparable target, Comparable[] list) {
   int index = 0;
   while (index < list.length) {
        if (list[index].compareTo(target) == 0)
           return index;
        else
           index++;
   }
   return -1;
}

Linear time algorithms: direct proportionality between input size and time
Sequential search is a linear time algorithm
Sequential search is also called linear search

Selection sort will always exhibit quadratic growth
Number of comparisons for a list of size n: C(n) = 1/2 (n^2 - n)

Deducing growth rates from code:

Whenever the bulk of an algorithm is performed in a single loop whose limits depend on the size of the input, we can expect a worst-case linear runtime growth as input size increases

When code is nested within two for loops and both loops have limits that are based on input size, wec an expect a worst-case quadratic runtime growth as input size increases

Insertion sort: divides input list into sorted and unsorted sublists
Best case for insertion sort is an already ordered list (C(n) = n - 1)
Worst case for insertion sort is a reverse-ordered list (C(n) = 1/2(n^2 - n))

Example: insertion sort for ints

public static void insertionSort(int[] list) {
    
    for (int unsortedStart = 1; unsortedStart < list.length; unsortedStart++) {
        int nextInsert = list[unsortedStart];
        int currentIndex = unsortedStart - 1;

        while (currentIndex >= 0 && list[currentIndex] > nextInsert) {
            list[currentIndex + 1] = list[currentIndex]
            currentIndex--;
        }

        list[currentIndex + 1] = nextInsert;
    }
}

A merge sort achieves linearithmic time regardless of inputs
Linearithmic is a combination of linear and logarithmic --> in the form n*log(n)

So far we have seen four times of runtime rates:
Constant - with getFront()
Linear - with linear search (worst case) and insertion sort (best case)
Linearithmic - with merge sort
Quadratic - with selection sort and insertion sort (worst case)

There are seven growth rates listed below with Big-O notation:
Constant - O(1)
Logarithmic - O(log(n))
Linear - O(n)
Linearithmic - O(nlog(n))
Quadratic - O(n^2)
Cubic - O(n^3)
Exponential - O(a^n)

Binary search algorithm offers logarithmic growth rate
For a binary search algorithm, the elements of the list to search must be sorted
Steps of a binary search algorithm:
1. Find the middle element of the list
2. Compare the middle element's value to that of the target item
3. If their values are equal, the target is found. Terminate
4. If the target item is greater than the middle element, perform steps 1-3 on the right sublist
5. If the target item is less than the middle element, perform steps 1-3 on the left sublist
6. Repeat the above until the target is found or the algorithm reaches a single element sublist
7. If the single element is not the target, the target is not in the list. Terminate

Example: binary search algorithm for arrays of Comparable objects

public static int binarySearch(Comparable[] list, Comparable target) {
    int start = 0, end = list.length, mid = 0;

    while (start <= end) {
        mid = (start + end) / 2;
        if (list[mid].compareTo(target) == 0)
            return mid;
        else if (target.compareTo(list[mid]) < 0)
            end = mid - 1;
        else
            start = mid + 1;
    }

    return -1;
}

Worst case runtime of a binary search is O(log_base2(n))

******************************
********** Module 7 **********
******************************

********************************************
***** Lesson 14: More About Interfaces *****
********************************************

After Java 8 it became possible to include concrete methods in an interface
Java supports 2 different kinds of concrete interface methods - default and static methods

Achieving backwards compatibility: we can add a default implementation of a method to an interface and all classes that implement that interface automatically gain the definition without having to recompile

Example: updating Groomable interface with default method

public interface Groomable {
    public void groom();

    default void pay() {
        System.out.println("Cha-Ching!");
    }
}

Recall: all method declarations in an interface are inherently public
You can override default methods just like other methods

Static methods can also be defined in interfaces
Recall: static methods are not associated with specific instances but represent a class-centric behavior

Example: updating Groomable interface with static method

public interface Groomable {

    public void groom();
    default void pay() {
        System.out.println("Cha-Ching!");
    }

    static String calculateTip(double price, double percentage) {
        double rawTip = price * (percentage / 100);
        return String.format("$%,.2f", rawTip);
    }
}

To run the method, we must precede the method name with the interface name

Example: Groomable.calculateTipe(39.99, 20)

Static interface methods cannot be overriden in classes

Interfaces can also contain constants
Any variable that is defined in an interface is inherently public, static, and final regardless of modifiers used

Placing constants in an interface can be useful for when classes should share data but have an inheritance relationship that is too limited for data sharing

A constant interface is one with no declared or defined methods

Example: constant interface

public interface ChemistryConstants {
    public static final double AVOGADROS_NUMBER = 6.02214199e23;
    public static final double FARADAY_CONSTANT = 96485.33;
    public static final double COULOMB_CONSTANT = 8.987551e9;
    public static final double PLANCK_CONSTANT = 6.62607004e34;
}

Anti-pattern: a programming practice that might solve a problem but is generally discouraged 
Constant interfaces are an anti-pattern because they represent a significant step away from the core intention of interfaces as constructs for declaring behaviors

An interface can extend another interface and inherit its constants and methods

Programmers of large code use UML class diagrams to map out hierarchies
UML syntax: rectangle with child class, arrow with hollow tip pointing to parent class, parent class is in rectangle
Interface nodes (rectangles) are specifically labelled with <<interface>>
Class node gets dotted arrow with hollow tip to the interface it is implementing
A client of a class would be drawn as the client node (rectangle) with a dotted arrow and open tip to the class nodes

Interfaces allow for a child class to have more than one parent class that it extends

***********************************
***** Lesson 15: Polymorphism *****
***********************************

Java objects can be polymorphic --> meaning that they exist in different forms
Polymorphism allows for flexibility in processing objects of different classes without having to write separate code for each class that has to be supported

The object type is the actual class that follows the new operator when an object is instantiated

Example: legal
Dog pixy;
pixy = new Poodle();
pixy.bark()

Example: not legal
Poodle pixy;
pixy = new Dog();
pixy.bark();

The second example would yield a compiler error since Dog cannot be converted to Poodle

Legally we can cast up and down an inheritance tree, as long as the target type has the variables or method being accessed

Matching a method call in a statement to its actual definition at runtime is known as dynamic binding
Dynamic binding is synonomous with late-binding or runtime resolution

**********************************************
***** Lesson 16: Exceptions and File I/O *****
**********************************************

Here are some Java class names for exceptions: 
NullPointerException
ArrayIndexOutOfBoundsException
StringIndexOutOfBoundsException
ArithmeticException
ClassCastException
IllegalArgumentException

An exception is an object that is thrown after an error occurs
It is possible to gracefully handle the runtime error and keep the program running

Example: process of throwing an error
"thirty" instead of 30 --> identified as unexpected type --> next method calls throwFor method --> creates an instance of InputMismatchException object --> object handled off JVM using Java operator "throw"

The call stack trace or stack trace is the list of method calls for an error message
Trace --> indicates the sequence of method calls that led to thrown exception
Stack --> indicates how method calls are internally managed by JVM

JVM uses a stack based data structure to facilitate saving and retrieval of method state

Main method is at bottom of stack, with most recent method on top
As methods complete they are pushed off the stack
When the main method is pushed off the stack it signals that the program is finished

Call stack is not accessible in our programs, it is managed internally

There is a hierarchy of exception types:
Throwable splits into Error or Exception
Error <-- VirtualMachineError <-- OutOfMemoryError
Exception splits into IOException and RuntimeException

At the top of all exception classes is the super class Throwable

A subclass of the Error class represents an error that generally can't be recovered from
Exceptions offer more flexibility in how they are handled

Try and catch --> framework for catching the exception object and handling it gracefully

Wrap the statements that may throw an exception with a try block

Syntax: 
try {
    // statements;
}

To actually catch a thrown exception the try block must be followed by a catch block

Syntax:
try {
    // statements;
} catch (ExceptionType identifier) {
    // statements;
}

When an exception occurs in the try block a reference to its object is passed into a catch block if the declared type matches the object type

Example: try catch block for multiple exceptions
try {
 statement(s);
} catch (ExceptionType1 identifier) {  
 statement(s);
} catch (ExceptionType2 identifier) {  
 statement(s);
} catch (ExceptionType3 identifier) {  
 statement(s);
}

Code that is dependent on statements that may throw an exception should be in the same try block

Once a program reaches a catch block it does not return to the try block

You can use an exception controlled loop --> while loop that re-runs the program if it reaches an exception

Example: exception controlled loop

import java.util.Scanner;
import java.util.InputMismatchException;

public class FahrenheitToCelsiusException {
    
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        boolean success = false;
        int fahrenheit = 0;

        while (!success) {

            try {
                System.out.println("Enter a F value :");
                fahrenheit = input.nextInt();
                success = true;
            } catch (InputMismatchException e) {
                input.nextLine();
                System.out.println("Sorry that was not an int.");
                System.out.println("Please try again.");
            }
        }

        double celsius = (5.0 / 9) * (farenheit - 32)
        System.out.printf("Farenheit : %d\n", farenheit);
        System.out.printf("Celsius:    %.1f\n", celsius);
    }
}

Typically --> system exit with 1 means not normal, system exit with 0 means normal

Try and catch blocks make code easier to read and write because it clearly delineates error handling while not messing up the core logic of the program

Using the superclass Exception as the object type for your catch block will match with any exception type

Useful instance methods of Throwable objects:
getMessage()
printStackTrace()

Example: try and catch for multiple exceptions

import java.util.Scanner;
import java.util.InputMismatchException;

public class FahrenheitToCelsiusException {
    
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        boolean success = false;
        int fahrenheit = 0;

        while (!success) {

            try {
                System.out.println("Enter a F value :");
                fahrenheit = input.nextInt();
                double celsius = (5.0 / 9) * (farenheit - 32)
                System.out.printf("Farenheit : %d\n", farenheit);
                System.out.printf("Celsius:    %.1f\n", celsius);
                success = true;
            } catch (InputMismatchException ime) {
                input.nextLine();
                System.out.println("Sorry that was not an int.");
                System.out.println("Please try again.");
            } catch (ArithmeticException ae) {
                System.out.println("You entered an invalid expression.");
                System.out.println(ae.getMessage());
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }
        }

    }
}

You can also combine catch blocks if their handling steps are the same
Use a vertical bar | to separate the exception types

The finally block contains statements that must execute regardless of whether the try block throws any exceptions
A finally block is always executed
Typically --> use a finally block for cleanup code

Syntax:

try {
    // statements
} catch {
    // statements
} finally {
    // statements
}

Example: file reader and writer 

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.io.PrintWriter;

public class FileTest {
    public static void main(String [] args) {
        String inputFileName = args[0];
        String word = args[1];

        File fileIn = new File(inputFileName);
        File fileOut = newFile(word + "In" + inputFileName);

        Scanner fileScan = null;
        PrintWriter filePrint = null;

        try {
            fileScan = new Scanner(fileIn);
            filePrint = new PrintWriter(fileOut);

            int lineCount = 0;
            filePrint.printf("Lines in %s containing %s:\n", args[0], args[1]);
            while (fileScan.hasNextLine()) {
                String line = fileScan.nextLine();
                if (line.contains(word)) {
                    filePrint.println(lineCount + ": " + line);
                }
                lineCount ++
            }
        } catch (FileNotFoundException e) {
            System.out.println(e.getMessage());
        } finally {
            if (fileScan != null) {
                fileScan.close();
            } 
            if (filePrint != null) {
                filePrint.close();
            }
        }
    }
}

Exceptions must either be caught or declared
To declare an exception you add the keyword throws with the exception name to the main header

Example: public static void main(String[] args) throws FileNotFoundException {}

In the Throwable hierarchy there are checked and unchecked exceptions
Checked exceptions must either be caught or specified
Unchecked exceptions do not have to be caught or specified

We can also write our own exceptions 

Example: making our own exception
public class DivideByZeroException extends ArithmeticException {
    public DivideByZeroException() {
        super("Divide by zero.");
    }
}

Example: using the throw operator
import java.util.Scanner;
import java.util. InputMismatchException;

public class FahrenheitToCelsiusExceptions {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("Enter a Fahrenheit value: ");
        try {
            int fahrenheit = input.nextInt();
            double celsius = (5.0/9) * (fahrenheit - 32);
            System.out.printf("Fahrenheit: %d\n", fahrenheit);
            System.out.printf("Celsius:    %.1f\n", celsius);
        if (fahrenheit == 0) {
        throw new DivideByZeroException();
        }
        double x = 1331/fahrenheit;
        }
        catch(InputMismatchException ime) {
            System.out.println("Sorry, that wasn't an int.");
            System.out.println("Please re-run the program again");
        }
        catch(DivideByZeroException dze) {
            System.out.println("Oops. You entered an invalid number:");
        System.out.println(dze.getMessage());
        }
        catch(Exception e) {
            System.out.println(e.getMessage());
        }
    }
}

A file with a .csv extension is likely a plain text file with comma delineated data
CSV stands for comma separated values

Example: using a split method
public static void main(String []args) {
    String chant = "Java Is The Best!";
    String[] tokens = chant.split(" ");
    for (String x : tokens) {
        System.out.println(x);
    }
}

Example: reading csv file and splitting
    public static void main(String[] args) {
        File fileIn = new File("SortedWolves.csv");
        Scanner fileScan = null;
        String[] tokens = null;
        double[] allWeights = new double[10];
        int index = 0;
        try {
            fileScan = new Scanner(fileIn);
            String line = null;
            while (fileScan.hasNextLine()) {
                line = fileScan.nextLine();
                tokens = line.split(",");
                allWeights[index] = Double.parseDouble(tokens[1]);
                index++;
            }
        } 
        catch (FileNotFoundException e) {
            System.out.println(e.getMessage());
        }

        finally {
            if (fileScan != null) {
                fileScan.close();
            }
        }
     } 

With split(), the delimiter does not have to be an exact String match, it can be a regular expression
A regular expression is a String formatted rule that represents a collection of actual delimiters

Example: regular expression to use uppercase letters as delimiters
      public static void main(String []args) {
          String chant = "Java Is The Best!";
          String[] tokens = chant.split("[A-Z]+");
          for (String x : tokens){
              System.out.println(x);
          }
     }

The Scanner class also allows us to parse delimited Strings
Syntax: Scanner(String source);

Example: using scanner to parse delimited Strings
    public static void main(String[] args) {
        File fileIn = new File("SortedWolves.csv");
        Scanner fileScan = null;
        Scanner wolfScan = null;
        double[] allWeights = new double[10];
        int index = 0;
        try {
            fileScan = new Scanner(fileIn);
            String line = null;
            while (fileScan.hasNextLine()) {
                line = fileScan.nextLine();
                wolfScan = new Scanner(line);
                wolfScan.useDelimiter(",");
                wolfScan.nextInt(); //consume unused rank token
                allWeights[index] = wolfScan.nextDouble();
                index++;  
            }
        } 
        catch (FileNotFoundException e) {
            System.out.println(e.getMessage());
        }
        finally {
            if (fileScan != null) {
                fileScan.close();
            }
        }
     }

The Scanner will use a default delimiter of whitespace so we must explicitly set it to be ","

******************************
********** MODULE 9 **********
******************************

************************************************
***** Lesson 17: Lists (and more Generics) *****
************************************************

Interface List<E> where E is the types of elements in this list

There are methods for interacting with the list like add(), clear(), contains(), remove(), size(), sort(), and other methods that are on the Java Oracle documentation page

The ArrayList class allows for a high-level way of using arrays as list
It is an implementation of the List interface with an array as the underlying data structure

Internally --> the ArrayList class declares an array instance variable called elementData
List methods such as add() or remove() interact with elementData

ArrayList is a generic class - can create with or without element type constraints
Using generic type with no actual type parameters --> called a raw type
Using generic type with actual type parameters provided --> called a parameterized type

Example: raw ArrayList instantiation
ArrayList playlist = new ArrayList();

It is possible to specify length, but not specifying length creates an internal Object array with an initial length of 10, with all locations as null references at the start

Example: creating ArrayList with different capacity
ArrayList playlist = new ArrayList(5);

Syntax: declaring and creating parameterized ArrayList
ArrayList<elementType> aList = new ArrayList<elementType>();
ArrayList<elementType> aList = new ArrayList<elementType>(initialCapacity);

After Java 7, type parameter on right side not required and is implied by left
Syntax:
ArrayList<elementType> aList = new ArrayList<>();
ArrayList<elementType> aList = new ArrayList<>(initialCapacity);

Note that even with parameterized ArrayLists the internal array elementData is still an Object array

Example: using ArrayList
import java.util.ArrayList;
public class StringArrayListDemo {
    public static void main(String[] args) {
        ArrayList<String> playlist = new ArrayList<>();
        playlist.add("Humpty Dumpty");
        playlist.add("Wheels on the Bus");
        System.out.println(playlist.toString());
        playlist.remove("Humpty Dumpty");
        System.out.println(playlist.toString());
    }
}

Autoboxing: Java creates an Object version of the primitive value using the matching wrapper type
For example, Java will create an Integer Object if you enter the primitive type int

You can still use a for-each loop to traverse an ArrayList

Example: using for-each loop
int sum = 0;
for (Integer score : scores) {
    sum += score; //autounboxing
}

ArrayLists are good for storing data but not for list manipulation because of their rigidity

Example: creating GenericLinkedList class
GenericLinkedList<String> favBabySongs = new GenericLinkedList<>();

Example: making a generic class out of a class

Regular Bin class:
public class Bin {
    private Object content;
    public Bin(Object content) {
        this.content = content;
    }
    public Object getContent() {
        return content;
    }
    public void setContent(Object content) {
        this.content = content;
    }
}

Generic Bin class:
public class Bin<T> {
    private T content;
    public Bin(T content) {
        this.content = content;
    }
    public T getContent() {
        return content;
    }
    public void setContent(T content) {
        this.content = content;
    }
}

Syntax: class header with multiple type parameters
visibility class name<T1, T2, ... Tn>

You can also restrict type parameters (called bounded type parameters) by having them extend interfaces
Note that syntactically it uses extends even for interfaces
Example: Bin<T extends Insect>
Example: Bin<T extends Insect & Comparable>

Basis of a LinkedList is a Node --> data is stored within the node
Nodes only created when you add new data to the LinkedList, and they are not placed in contiguous memory locations like with ArrayList
Each node links to the next node, hence the term LinkedList

Example: node class
private class Node<E> {
    E data;
    Node<E> next;

    Node(E data, Node<E> next) {
        this.data = data;
        this.next = next;
    }
}

Example: creating first node
Node<E> node = new Node<E>(newData, null);

Head reference points to first node
Syntax: head = new Node<E>(data, head);

The method addToFront() adds a node to the front of the list; you must also make sure the head now points to this new first node

Traversal of a LinkedList needs a reference other than head, usually called current
Example: traversing through a linked list
Node current = head;
while (current != null) {
    current = current.next;
}

Example: method for adding to rear of linked list

public void addToRear(E newData) {
    Node<E> node = new Node<E>(newData, null);
    Node<E> current = head;
    if (head == null)
        head = node;
    else {
        while (current.next != null) {
            current = current.next;
        }
        current.next = node;
    }
}

Example: GenericLinkedList class for creating a list to store elements of specific types

public class GenericLinkedList<E> {

    private class Node<E> { //inner class
        E data;
        Node<E> next;

        Node(E data, Node<E> next) {
            this.data = data;
            this.next = next;
        }
    }

    private Node<E> head; //the only instance variable of the list

    public GenericLinkedList() {

        head = null;  //the list starts off empty
    }

    public boolean isEmpty() {
        return (head == null); //the list is empty if head is null
    }

    public void addToFront(E newData) {
        head = new Node<E>(newData, head);
    }

    public void addToRear(E newData) {
        Node<E> node = new Node <E> (newData, null);
        Node<E> current = head;
        if (isEmpty())  //point head to new node if list is empty
            head = node;
        else {
           while (current.next != null) { //the last node is the one with next = null
               current = current.next;
           }
           current.next = node;
        }
    }

    public String toString() {

        Node<E> current = head; //traversal starts at the front
        String result = ""; //result starts empty

        while (current != null) {  //keep going until there's no more nodes to point to
            result = result + current.data.toString() + "\n";
            current = current.next; //move over to next node
        }
        return result;
    }

    public boolean contains(E target) {
        if (isEmpty()) {  //empty lists can't contain the target
            return false;
        }

        boolean found = false;
        Node<E> current = head; //traversal starts at the front

        while ((current != null) && (!found)) {
            if (target.equals(current.data)) {
                found = true;
            } else {
                current = current.next;
            }
        }
        return found;
    }

    public static void main(String[] args) {
        GenericLinkedList<String> favBabySongs = new GenericLinkedList<>();
        favBabySongs.addToFront("Humpty Dumpty");
        favBabySongs.addToRear("Swing Low Sweet Chariot");
        favBabySongs.addToFront("Itsy Bitsy Spider");
        favBabySongs.addToRear("Twinkle, Twinkle Little Star");
        favBabySongs.addToFront("Wheels on the Bus");
        System.out.println(favBabySongs.toString());
        System.out.println(favBabySongs.contains("Humpty Dumpty"));
        System.out.println(favBabySongs.contains("Baby Shark"));
    }
}

In the above example code, Node is an example of a private inner class
Node has no application beyond its use as a storage element of GenericLinkedList so it is contained in that class

Example: removeFromRear() and removeFromFront() for GenericLinkedList.java

    public E removeFromRear() {
        E removedData;

        if (isEmpty()) {
            removedData = null;
        } 
        else if (head.next == null) {
            removedData = head.data;
            head = null;
        } 
        else {
            Node<E> current = head;
            while (current.next.next != null) {
                current = current.next;
            }
            removedData = current.next.data;
            current.next = null;
        }

        return removedData;
    }

    public E removeFromFront() {
        if (isEmpty()) {
            return null;
        }

        E removedData = head.data;
        head = head.next;
        return removedData;
    }

Linked lists vs. ArrayLists: ArrayLists are more attractive because they provide faster data reads due to random access nature of arrays that back them

ArrayList method get(int index) executes in constant time no matter elementData's length or index
Linked lists require traversing the list until the index is reached, executes in (worst case) linear time

********************************
***** Lesson 18: Recursion *****
********************************

Recursion happens when a method calls itself

Example: 

public class Repeated {
    public static void main(String[] args) {
        repeatString("I heart Java", 1331);
    }
    public static void repeatString(String toRepeat, int times) {
        if (times <= 0) {
            return;
        }
        System.out.println(toRepeat);
        repeatString(toRepeat, times - 1);
    }
}

In this example, (times - 1) is known as a reduction statement

StackOverflowError is an error that cannot be handled --> it occurs when methods continue to get added on the stack until there is no space for a new stack frame to be created

In order for a recursive method to complete it needs:
- a terminating condition (also called base case) that returns without making a recursive call
- a reduction step that moves the direction of the recursive call towards the terminating condition
- a recursive call

Example: another recursive method
public static int factorial(int n) {
   if (n >= 0) {
       return realFactorial(n);
   }
   else {
       throw new IllegalArgumentException("Non-negative input required");
    }
}

private static int realFactorial(int n) {
   if (n == 0) {
       return 1;
    }
   else {
       return n * realFactorial(n-1);
   }
}

Example: reversing a String
public static void reverse(String s) {
    if (s.length() == 0) {
        System.out.println();
    } else {
        System.out.print(s.charAt(s.length - 1));
        reverse(s.substring(0, s.length - 1));
    }
}

*******************************
********** MODULE 10 **********
*******************************

*********************************************
***** Lesson 19: Introduction to JavaFX *****
*********************************************

This will serve as an intro for creating graphical user interfaces (GUIs)

The window is called the stage
The content inside the window is called the scene

Example: hello world program

import javafx.application.Applicationl
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class HelloWorldGUI extends Application {
    public static void main(String[] args) {
        launch(args)
    }
    public void start(Stage mainStage) {
        mainStage.setTitle("Hello World Program");

        Button btn = new Button();
        btn.setText("Print Hello World!");
        btn.setOnAction(new CustomEventHandler());

        StackPane root = new StackPane();
        root.getChildren().add(btn);

        Scene scene = new Scene(root, 300, 300);
        mainStage.setScene(scene);
        mainStage.show();
    }
    private class CustomEventHandler implements EventHandler<ActionEvent> {
        public void handle(ActionEvent event) {
            System.out.println("Hello World!");
        }
    }
}

To compile GUI app use terminal command: $ javac --module-path javafx-sdk-11.0.2/lib --add-modules=javafx.controls HelloWorld.java
(replacing HelloWorld with your desired file name)
Note that the file should be in the same folder as your test programs
To run the GUI app use terminal command: $ java --module-path javafx-sdk-11.0.2/lib --add-modules=javafx.controls HelloWorld

The start method is an abstract method from Application that must always be overwritten in your GUI program
You do not explicitly need a main method

There are a hierarchy of events that can occur on a GUI, with the super class being Event

Convention in GUI programming is to say that events are fired rather than created

Any event handling program must implement the interface EventHander<T extends Event>
Note HelloWorldGUI example private inner class implementation

A functional interface is an interface that has only one abstract method

Note types and class names:
Layouts: FlowPane, GridPane, BorderPane, HBox, StackPane, VBox, etc.
Shapes: Circle, Rectangle, etc.
Images: ImageView
Controls: Button, CheckBox, TextField, Label

Refer to example above for reference of root and button:
Root is the top level node of the stack graph (contains every other node)
Button node is a leaf node, meaning it is at the bottom

Example: scene graph
root node --> branch node --> leaf node, leaf node

Anonymous inner classes are a way to define single use classes in a single line

Example: anonymous inner class
EventHandler<ActionEvent> handler = new EventHandler<>() {
    public void handle(ActionEvent event) {
        System.out.println("Hello World!");
    }
};

Lambda expressions can be used to replace anonymous inner classes
The lambda expression symbol is an arrow: ->

We can omit formal parameter type in a lambda expression and if the method definition is only one line, we can omit the curly braces as well

Example: HelloWorldGUI with lambda expression
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class HelloWorldLambda extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    public void start(Stage mainStage) {
        mainStage.setTitle("Hello World Program (Lambda)");

        Button btn = new Button();
        btn.setText("Print Hello World!");
        btn.setOnAction(event -> System.out.println("Hello World!"));
        StackPane root = new StackPane();
        root.getChildren().add(btn);

        Scene scene = new Scene(root, 300, 300);
        mainStage.setScene(scene);
        mainStage.show();
    }
}

Oracle has good JavaFX documentation like for using built in layout panes or different label classes

BorderPane provides 5 regions: top, left, center, right, bottom
HBox: lines nodes up horizontally in a row
VBox: lines nodes up vertically in a column
GridPane: allows you to place nodes in a grid like pattern

Label allows for placing text on screen
TextField accepts and displays user text
Many more classes within Oracle documentation
